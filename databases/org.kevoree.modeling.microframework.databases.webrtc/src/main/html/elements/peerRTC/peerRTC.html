<link rel="import" href="../../../resources/bower_components/polymer/polymer.html">

<polymer-element name="peer-rtc">
    <template>
        <link rel="stylesheet" href="peerRTC.css">

        <h1>RTCDataChannel</h1>

        <div id="buttons">
            <button on-click="{{createConnection}}" id="startButton">Start</button>
            <button on-click="{{sendData}}" id="sendButton">Send</button>
            <button on-click="{{closeDataChannels}}" id="closeButton">Stop</button>
        </div>
        <div id="sendReceive">
            <div id="send">
                <h2>Send</h2>
                <textarea id="dataChannelSend" disabled
                          placeholder="Press Start, enter some text, then press Send."></textarea>
            </div>
            <div id="receive">
                <h2>Receive</h2>
                <textarea id="dataChannelReceive" disabled></textarea>
            </div>
        </div>

        <p>View the console to see logging.</p>

        <p>The <code>RTCPeerConnection</code> objects <code>localPeerConnection</code> and
            <code>remotePeerConnection</code> are in global scope, so you can inspect them in the console as well.</p>
    </template>
    <script src="../../../js/adapter.js"></script>
    <script>
        Polymer({
            /*  db = levelup('/does/not/matter', { db: require('memdown') })
            memdown: require('../../../resources/memdown'),
            db: levelup(memdown),
            */
            html5rocks: {},

            id: null, /* Our unique ID */
            sharedKey: null, /* Unique identifier for two clients to find each other */
            remote: null, /* ID of the remote peer -- set once they send an offer */

            /* Keep track of our connection state */
            running: false,
            /* Use Google's public servers for STUN
             * STUN is a component of the actual WebRTC connection
             * */
            servers: {iceServers: [{url: 'stun:stun.l.google.com:19302'}]},

            peerConnection: null, /* This is our WebRTC connection */
            dataChannel: null, /* This is our outgoing data channel within WebRTC */

            ready: function () {
                /* Generate this browser a unique ID */
                this.id = Math.random().toString().replace('.', '');
                /* Unique identifier for two clients, They MUST share this to find each other
                * Each peer waits in the announcement channel to find its matching identifier
                * When it finds its matching identifier, it initiates a WebRTC offer with that client.
                * This unique identifier can be pretty much anything in practice.
                */
                this.sharedKey = prompt("Please enter a shared identifier");

                //adaptator.setRTCValues();
                //var announceChannel = this.handleAnnounceChannelMessage;
                //var signalChannel = this.handleSignalChannelMessage;

                /* Send a message to the announcement channel
                * If our partner is already waiting, they will send us a WebRTC offer
                * over signalling channel and we can begin delegating WebRTC
                */
                this.sendAnnounceChannelMessage();
            },
            // Handle an incoming message on the announcement channel
            handleAnnounceChannelMessage: function (snapshot) {
                var message = snapshot.val();
                if (message.id != id && message.sharedKey == sharedKey) {
                    console.log('Discovered matching announcement from ' + message.id);
                    this.remote = message.id;
                    this.initiateWebRTCState();
                    //this.connect();
                }
            },
            // This is the general handler for a message from our remote client
            // Determine what type of message it is, and call the appropriate handler
            handleSignalChannelMessage: function (snapshot) {
                var message = snapshot.val();
                var sender = message.sender;
                var type = message.type;
                console.log('Received a \'' + type + '\' signal from ' + sender);
                //if (type == 'offer') handleOfferSignal(message);
                //else if (type == 'answer') handleAnswerSignal(message);
                //else if (type == 'candidate' && running) handleCandidateSignal(message);
            },
            // Announce our arrival to the announcement channel
            sendAnnounceChannelMessage: function () {
                this.db.put(this.sharedKey, this.id, function (err) {
                    if (err) { // some kind of I/O error
                        return console.log('Ooops! Put didn\'t work', err);
                    }
                });
                this.db.remove(function () {
                    this.db.push({sharedKey: sharedKey, id: id});
                });
                console.log('Announced our sharedKey is ' + sharedKey);
                console.log('Announced our ID is ' + id);
            },
            // Function to initiate the WebRTC peerconnection and dataChannel
            initiateWebRTCState: function () {
                //adaptator.trace('Created remote peer connection object peerConnection');
                this.peerConnection = new webkitRTCPeerConnection(servers);//new adaptator.RTCPeerConnection(servers, pcConstraint);
                //this.peerConnection.ondatachannel = handleDataChannel;
                this.dataChannel = peerConnection.createDataChannel('myDataChannel');
                //this.dataChannel.onmessage = handleDataChannelMessage;
                //this.dataChannel.onopen = handleDataChannelOpen;
            },
            // Function to offer to start a WebRTC connection with a peer
            connect: function () {
                this.running = true;
                //this.startSendingCandidates();
                this.peerConnection.createOffer( function ( sessionDescription ) {
                    console.log('Sending offer to ' + remote);
                    this.peerConnection.setLocalDescription( sessionDescription );
                    //this.sendSignalChannelMessage( sessionDescription );
                });
            }

        });
    </script>
</polymer-element>