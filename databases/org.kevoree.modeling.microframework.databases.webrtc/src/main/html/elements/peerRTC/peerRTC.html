<link rel="import" href="../../../resources/bower_components/polymer/polymer.html">

<polymer-element name="peer-rtc">
    <template>
        <link rel="stylesheet" href="peerRTC.css">

        <h1>RTCDataChannel</h1>

        <div id="buttons">
            <button on-click="{{createConnection}}" id="startButton">Start</button>
            <button on-click="{{sendData}}" id="sendButton">Send</button>
            <button on-click="{{closeDataChannels}}" id="closeButton">Stop</button>
        </div>
        <div id="sendReceive">
            <div id="send">
                <h2>Send</h2>
                <textarea id="dataChannelSend" disabled
                          placeholder="Press Start, enter some text, then press Send."></textarea>
            </div>
            <div id="receive">
                <h2>Receive</h2>
                <textarea id="dataChannelReceive" disabled></textarea>
            </div>
        </div>

        <p>View the console to see logging.</p>

        <p>The <code>RTCPeerConnection</code> objects <code>localPeerConnection</code> and
            <code>remotePeerConnection</code> are in global scope, so you can inspect them in the console as well.</p>
    </template>
    <script src="../../../js/adapter.js"></script>
    <script>
        Polymer({
            /*  db = levelup('/does/not/matter', { db: require('memdown') })
            memdown: require('../../../resources/memdown'),
            db: levelup(memdown),
            */
            html5rocks: {},

            id: null, /* Our unique ID */
            sharedKey: null, /* Unique identifier for two clients to find each other */
            remote: null, /* ID of the remote peer -- set once they send an offer */

            /* Keep track of our connection state */
            running: false,
            /* Use Google's public servers for STUN
             * STUN is a component of the actual WebRTC connection
             * */
            servers: {iceServers: [{url: 'stun:stun.l.google.com:19302'}]},

            peerConnection: null, /* This is our WebRTC connection */
            dataChannel: null, /* This is our outgoing data channel within WebRTC */

            ready: function () {
                this.html5rocks.indexedDB = {};
                this.html5rocks.indexedDB.db = null;

                this.html5rocks.indexedDB.open = function() {
                    var version = 1;
                    var request = this.indexedDB.open("signaling", version);

                    // We can only create Object stores in a versionchange transaction.
                    request.onupgradeneeded = function(e) {
                        var db = e.target.result;
                        // A versionchange transaction is started automatically.
                        e.target.transaction.onerror = this.html5rocks.indexedDB.onerror;
                        if(db.objectStoreNames.contains("signal")) {
                            db.deleteObjectStore("signal");
                        }
                        var store = db.createObjectStore("signal",
                                {keyPath: "sharedKey"});
                    };
                    request.onsuccess = function(e) {
                        this.html5rocks.indexedDB.db = e.target.result;
                        this.html5rocks.indexedDB.getAllTodoItems();
                    };
                    request.onerror = this.html5rocks.indexedDB.onerror;
                };
/*
                // Which we then observe
                Object.observe(this.html5rocks.indexedDB.db, function(changes){
                    // This asynchronous callback runs
                    changes.forEach(function(change) {
                        // Letting us know what changed
                        console.log(change.type, change.name, change.oldValue);
                    });
                });
*/
                /* Generate this browser a unique ID */
                this.id = Math.random().toString().replace('.', '');
                /* Unique identifier for two clients, They MUST share this to find each other
                * Each peer waits in the announcement channel to find its matching identifier
                * When it finds its matching identifier, it initiates a WebRTC offer with that client.
                * This unique identifier can be pretty much anything in practice.
                */
                this.sharedKey = prompt("Please enter a shared identifier");

                //adaptator.setRTCValues();
                //var announceChannel = this.handleAnnounceChannelMessage;
                //var signalChannel = this.handleSignalChannelMessage;

                /* Send a message to the announcement channel
                * If our partner is already waiting, they will send us a WebRTC offer
                * over signalling channel and we can begin delegating WebRTC
                */
                this.sendAnnounceChannelMessage();
            },

            // Handle an incoming message on the announcement channel
            handleAnnounceChannelMessage: function (snapshot) {
                var message = snapshot.val();
                if (message.id != id && message.sharedKey == sharedKey) {
                    console.log('Discovered matching announcement from ' + message.id);
                    this.remote = message.id;
                    this.initiateWebRTCState();
                    //this.connect();
                }
            },
            // This is the general handler for a message from our remote client
            // Determine what type of message it is, and call the appropriate handler
            handleSignalChannelMessage: function (snapshot) {
                var message = snapshot.val();
                var sender = message.sender;
                var type = message.type;
                console.log('Received a \'' + type + '\' signal from ' + sender);
                //if (type == 'offer') handleOfferSignal(message);
                //else if (type == 'answer') handleAnswerSignal(message);
                //else if (type == 'candidate' && running) handleCandidateSignal(message);
            },
            // Announce our arrival to the announcement channel
            sendAnnounceChannelMessage: function () {
                var db = this.html5rocks.indexedDB.db;
                var trans = db.transaction(["signal"], "readwrite");
                var store = trans.objectStore("signal");
                var request = store.put({
                    "id": id,
                    "sharedKey" : sharedKey
                });
                console.log('Announced our sharedKey is ' + sharedKey);
                console.log('Announced our ID is ' + id);
            },
            // Function to initiate the WebRTC peerconnection and dataChannel
            initiateWebRTCState: function () {
                //adaptator.trace('Created remote peer connection object peerConnection');
                this.peerConnection = new webkitRTCPeerConnection(servers);//new adaptator.RTCPeerConnection(servers, pcConstraint);
                //this.peerConnection.ondatachannel = handleDataChannel;
                this.dataChannel = peerConnection.createDataChannel('myDataChannel');
                //this.dataChannel.onmessage = handleDataChannelMessage;
                //this.dataChannel.onopen = handleDataChannelOpen;



            },
            // Function to offer to start a WebRTC connection with a peer
            connect: function () {
                this.running = true;
                //this.startSendingCandidates();
                this.peerConnection.createOffer( function ( sessionDescription ) {
                    console.log('Sending offer to ' + remote);
                    this.peerConnection.setLocalDescription( sessionDescription );
                    //this.sendSignalChannelMessage( sessionDescription );
                });
            }

        });
    </script>
</polymer-element>